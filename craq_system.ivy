#lang ivy1.7

include spec
include trans

isolate system = {
    object server(self: node) = {
	function dBitMap(K: key) : bool
	function highestVersion(K: key) : ver_num.t
	instance mvMap : ordered_map(key_tups, value)
	individual ver_no: ver_num.t
	individual req_no: req_num.t

	action set(k: key, d: value)
	action get(k:key)
	action tail_commit(rq: query)

	import action answer(k: key, v: value, id: req_num.t)
	
	after init {
	    dBitMap(K) := false;
	    highestVersion(K) := 0
	}

	implement set(k: key, v: value) {
            var q: query;
            q.qkey := k;
            q.qtype := write;
            q.qvalue := v;
            q.qsrc := self;
	    q.qid := req_no;
	    req_no := req_no.next;
	    
            if self = 0:node {
		ver_no := ver_no.next;
		q.qvnum := ver_no;
		
		var key_pair : key_tups.t;
		key_pair.x := k;
		key_pair.y := ver_no;
		mvMap.set(key_pair, v);
		
		dBitMap(k) := true;
		highestVersion(k) := ver_no;
		if ~(self = node.max) {
		    call trans.send_request(self, self.next, q);
		} else {
		    call tail_commit(q)
		}
            } else {
		call trans.send_request(self, 0:node, q);
            }
	}

	implement trans.handle_request(rq: query) {
	    # assert rq.qtype = write
	    if self = 0:node {
		call set(rq.qkey, rq.qvalue)
	    } else if ~(self = node.max) { 
		var key_pair : key_tups.t;
		key_pair.x := rq.qkey;
		key_pair.y := rq.qvnum;

		mvMap.set(key_pair, rq.qvalue);
		
		# Update dirty bit map
		dBitMap(rq.qkey) := true;
		
		# Safe because network messages delivered in-order
		highestVersion(rq.qkey) := rq.qvnum;
		
		# Forward query
		call trans.send_request(self, self.next, rq)
	    } else {
		# if tail
		call tail_commit(rq: query)
	    }
	}

	implement tail_commit(rq: query) {
	    call spec.commit(rq, rq);
	    call trans.send_reply(self, self, rq)
	}
	
	implement get(k:key) {
            var q: query;
            q.qkey := k;
            q.qtype := read;
            q.qsrc := self;
	    q.qid := req_no;
	    req_no := req_no.next;

            if ~dBitMap(k) {
		var rep := q;

		var key_pair : key_tups.t;
		key_pair.x := k;
		key_pair.y := highestVersion(k);

		# 0 is the default value
		rep.qvalue := mvMap.get(key_pair, 0);

		call spec.commit(q, rep);
		call trans.send_reply(self, self, rep);
            } else {
		# Send inquire message to tail
		call trans.send_inquire(self, node.max, q);
            }
	}

	implement trans.handle_reply(q: query) {
            call answer(q.qkey, q.qvalue, q.qid);
        }

	implement trans.handle_inquire(rq: query) {
	    # TODO
	}

	implement trans.handle_inform(rq: query) {
	    # TODO
	}
    }

    # unique requests and replies to enable trans.send_reply, trans.send_request
    # enable trans.send_reply from trans.handle_request
    invariant ~(trans.requested(R1, D1) & trans.replied(R2, D2) & query.qsrc(R1) = query.qsrc(R2) & query.qid(R1) = query.qid(R2))
    # enable trans.send_request from trans.handle_request
    invariant trans.requested(R1, D1) & trans.requested(R2, D2) & query.qsrc(R1) = query.qsrc(R2) & query.qid(R1) = query.qid(R2) -> R1 = R2 & D1 = D2
    # enable trans.send_request from system.set, system.get
    invariant trans.requested(R, D) -> query.qid(R) < server(query.qsrc(R)).req_no
    # enable trans.send_reply from system.set, system.get
    invariant trans.replied(R, D) -> query.qsrc(R) = D & query.qid(R) < server(query.qsrc(R)).req_no

} with spec, trans, node, key_tups
